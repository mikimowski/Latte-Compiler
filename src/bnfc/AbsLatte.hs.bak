

module AbsLatte where

instance Show Ident where
  show (Ident ident) = ident

instance Show (Type a) where
    show (TArray _ t) = show t ++ "[]"
    show (TClass _ ident) = show ident
    show (TInt _) = "int"
    show (TStr _) = "string"
    show (TBool _) = "boolean"
    show (TVoid _) = "void"


instance (Eq a) => Eq (Type a) where
  (TClass _ ident1) == (TClass _ ident2) = ident1 == ident2
  (TInt _) == (TInt _) = True
  (TStr _) == (TStr _) = True
  (TBool _) == (TBool _) = True
  (TVoid _) == (TVoid _) = True
  (TArray _ type1) == (TArray _ type2) = type1 == type2
  _ == _ = False

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Read)
data Program a = Program a [TopDef a]
  deriving (Eq, Ord, Show, Read)

instance Functor Program where
    fmap f x = case x of
        Program a topdefs -> Program (f a) (map (fmap f) topdefs)
data TopDef a
    = TopClassDef a (ClassDef a) | TopFuncDef a (FuncDef a)
  deriving (Eq, Ord, Show, Read)

instance Functor TopDef where
    fmap f x = case x of
        TopClassDef a classdef -> TopClassDef (f a) (fmap f classdef)
        TopFuncDef a funcdef -> TopFuncDef (f a) (fmap f funcdef)
data FuncDef a = FuncDef a (Type a) Ident [Arg a] (Block a)
  deriving (Eq, Ord, Show, Read)

instance Functor FuncDef where
    fmap f x = case x of
        FuncDef a type_ ident args block -> FuncDef (f a) (fmap f type_) ident (map (fmap f) args) (fmap f block)
data Arg a = Arg a (Type a) Ident
  deriving (Eq, Ord, Show, Read)

instance Functor Arg where
    fmap f x = case x of
        Arg a type_ ident -> Arg (f a) (fmap f type_) ident
data ClassMember a
    = ClassField a (Type a) Ident | ClassMethod a (FuncDef a)
  deriving (Eq, Ord, Show, Read)

instance Functor ClassMember where
    fmap f x = case x of
        ClassField a type_ ident -> ClassField (f a) (fmap f type_) ident
        ClassMethod a funcdef -> ClassMethod (f a) (fmap f funcdef)
data ClassDef a
    = ClassDef a Ident [ClassMember a]
    | ClassExtDef a Ident Ident [ClassMember a]
  deriving (Eq, Ord, Show, Read)

instance Functor ClassDef where
    fmap f x = case x of
        ClassDef a ident classmembers -> ClassDef (f a) ident (map (fmap f) classmembers)
        ClassExtDef a ident1 ident2 classmembers -> ClassExtDef (f a) ident1 ident2 (map (fmap f) classmembers)
data Block a = Block a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Block where
    fmap f x = case x of
        Block a stmts -> Block (f a) (map (fmap f) stmts)
data Stmt a
    = Empty a
    | BStmt a (Block a)
    | Decl a (Type a) [Item a]
    | Ass a (Expr a) (Expr a)
    | Incr a (Expr a)
    | Decr a (Expr a)
    | Ret a (Expr a)
    | VRet a
    | Cond a (Expr a) (Stmt a)
    | CondElse a (Expr a) (Stmt a) (Stmt a)
    | While a (Expr a) (Stmt a)
    | For a (Type a) Ident (Expr a) (Stmt a)
    | SExp a (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Stmt where
    fmap f x = case x of
        Empty a -> Empty (f a)
        BStmt a block -> BStmt (f a) (fmap f block)
        Decl a type_ items -> Decl (f a) (fmap f type_) (map (fmap f) items)
        Ass a expr1 expr2 -> Ass (f a) (fmap f expr1) (fmap f expr2)
        Incr a expr -> Incr (f a) (fmap f expr)
        Decr a expr -> Decr (f a) (fmap f expr)
        Ret a expr -> Ret (f a) (fmap f expr)
        VRet a -> VRet (f a)
        Cond a expr stmt -> Cond (f a) (fmap f expr) (fmap f stmt)
        CondElse a expr stmt1 stmt2 -> CondElse (f a) (fmap f expr) (fmap f stmt1) (fmap f stmt2)
        While a expr stmt -> While (f a) (fmap f expr) (fmap f stmt)
        For a type_ ident expr stmt -> For (f a) (fmap f type_) ident (fmap f expr) (fmap f stmt)
        SExp a expr -> SExp (f a) (fmap f expr)
data Item a = NoInit a Ident | Init a Ident (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Item where
    fmap f x = case x of
        NoInit a ident -> NoInit (f a) ident
        Init a ident expr -> Init (f a) ident (fmap f expr)
data Type a
    = TClass a Ident
    | TInt a
    | TStr a
    | TBool a
    | TVoid a
    | TArray a (Type a)
  deriving (Ord, Read)

instance Functor Type where
    fmap f x = case x of
        TClass a ident -> TClass (f a) ident
        TInt a -> TInt (f a)
        TStr a -> TStr (f a)
        TBool a -> TBool (f a)
        TVoid a -> TVoid (f a)
        TArray a type_ -> TArray (f a) (fmap f type_)
data Expr a
    = ENewObject a (Type a)
    | ENewArray a (Type a) (Expr a)
    | EMember a (Expr a) Ident
    | EMemberCall a (Expr a) Ident [Expr a]
    | EVar a Ident
    | ELitInt a Integer
    | ELitTrue a
    | ELitFalse a
    | EString a String
    | EApp a Ident [Expr a]
    | EArrGet a (Expr a) (Expr a)
    | ECast a Ident
    | Neg a (Expr a)
    | Not a (Expr a)
    | EMul a (Expr a) (MulOp a) (Expr a)
    | EAdd a (Expr a) (AddOp a) (Expr a)
    | ERel a (Expr a) (RelOp a) (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        ENewObject a type_ -> ENewObject (f a) (fmap f type_)
        ENewArray a type_ expr -> ENewArray (f a) (fmap f type_) (fmap f expr)
        EMember a expr ident -> EMember (f a) (fmap f expr) ident
        EMemberCall a expr ident exprs -> EMemberCall (f a) (fmap f expr) ident (map (fmap f) exprs)
        EVar a ident -> EVar (f a) ident
        ELitInt a integer -> ELitInt (f a) integer
        ELitTrue a -> ELitTrue (f a)
        ELitFalse a -> ELitFalse (f a)
        EString a string -> EString (f a) string
        EApp a ident exprs -> EApp (f a) ident (map (fmap f) exprs)
        EArrGet a expr1 expr2 -> EArrGet (f a) (fmap f expr1) (fmap f expr2)
        ECast a ident -> ECast (f a) ident
        Neg a expr -> Neg (f a) (fmap f expr)
        Not a expr -> Not (f a) (fmap f expr)
        EMul a expr1 mulop expr2 -> EMul (f a) (fmap f expr1) (fmap f mulop) (fmap f expr2)
        EAdd a expr1 addop expr2 -> EAdd (f a) (fmap f expr1) (fmap f addop) (fmap f expr2)
        ERel a expr1 relop expr2 -> ERel (f a) (fmap f expr1) (fmap f relop) (fmap f expr2)
        EAnd a expr1 expr2 -> EAnd (f a) (fmap f expr1) (fmap f expr2)
        EOr a expr1 expr2 -> EOr (f a) (fmap f expr1) (fmap f expr2)
data AddOp a = Plus a | Minus a
  deriving (Eq, Ord, Show, Read)

instance Functor AddOp where
    fmap f x = case x of
        Plus a -> Plus (f a)
        Minus a -> Minus (f a)
data MulOp a = Times a | Div a | Mod a
  deriving (Eq, Ord, Show, Read)

instance Functor MulOp where
    fmap f x = case x of
        Times a -> Times (f a)
        Div a -> Div (f a)
        Mod a -> Mod (f a)
data RelOp a = LTH a | LE a | GTH a | GE a | EQU a | NE a
  deriving (Eq, Ord, Show, Read)

instance Functor RelOp where
    fmap f x = case x of
        LTH a -> LTH (f a)
        LE a -> LE (f a)
        GTH a -> GTH (f a)
        GE a -> GE (f a)
        EQU a -> EQU (f a)
        NE a -> NE (f a)
